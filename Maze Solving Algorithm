// Includes
#include "globs.h"
#include "physical_constants.h"
#include "main_control_task.h"
#include "leds_task.h"
#include "debug_printf.h"

#define QTR_THRESHOLD (0.5f)
#define NOMINAL_SPEED (0.25f)

enum maze_mode_t
{
    TRACK_LINE,
    TURN_LEFT,
    TURN_RIGHT,
    ADVANCE,
    ADVANCE_BACKWARDS,
    TERMINATION
};

// Global Functions
float determine_line_pos(uint8_t qtr_state, float last_line_pos, uint8_t num_qtr_on);

// Global Tuning
PidController track_maze_line_pid(20.0, 20.0, 0, -1, 1, -4, 4);

// Global Variables
float degrees_ = 1.5708;  // 90 Degrees in Radians
float turn_distance = 0.089f*degrees_;
float ENCODER_DIST = 0.089f*2.0f*PI/29.86f/12.0f;

// Main Control Task - Custom Mode for Maze Tracking
void MainControlTask::customMode(void)
{
    static float line_position;
    static float start_distance = 0.0f;
    static maze_mode_t maze_mode = TRACK_LINE;
    uint8_t qtr_state = 0;
    uint8_t num_qtr_on = 0;
    float delta_speed = 0.0f, left_speed_command = 0.0f, right_speed_command = 0.0f;

    for (uint8_t i = 0; i< 8; i++)
    {
        if (analog_.voltages[i] > QTR_THRESHOLD)
        {
            qtr_state |= 1<<i;
            num_qtr_on++;
        }
    }
    leds_task.requestNewLedGreenPattern(qtr_state);
    line_position = determine_line_pos(qtr_state, line_position, num_qtr_on);

    switch(maze_mode)
    {
        case TRACK_LINE:
                delta_speed = track_maze_line_pid.calculate(0.0f - line_position, delta_t_);
                left_speed_command = NOMINAL_SPEED + delta_speed;
                right_speed_command = NOMINAL_SPEED - delta_speed;

                if ((num_qtr_on > 3) ||(num_qtr_on == 0))
                {
                    maze_mode = ADVANCE;
                    start_distance = odometry_.avg_distance;
                    debug_printf("Node Found");
                }
                break;

        case ADVANCE:
                left_speed_command = NOMINAL_SPEED;
                right_speed_command= NOMINAL_SPEED;
                if ((odometry_.avg_distance - start_distance) > 0.02f)
                {
                    left_speed_command = 0.0f;
                    right_speed_command = 0.0f;
                }
                break;

        case TERMINATION:
                left_speed_command = 0.0f;
                right_speed_command = 0.0f;
                break;

        case TURN_LEFT:
                left_speed_command = 0.0f;
                right_speed_command = NOMINAL_SPEED;
                if ( ENCODER_DIST >= turn_distance)
                {
                    left_speed_command = 0.0f;
                    right_speed_command = 0.0f;
                }
                break;

        case TURN_RIGHT:
                left_speed_command = NOMINAL_SPEED;
                right_speed_command = 0.0f;
                if ( ENCODER_DIST >= turn_distance)
                {
                    left_speed_command = 0.0f;
                    right_speed_command = 0.0f;
                }
                break;

        case ADVANCE_BACKWARDS:
                left_speed_command = -NOMINAL_SPEED;
                right_speed_command = -NOMINAL_SPEED;
                if ((odometry_.avg_distance - start_distance) > 0.02f)
                {
                    left_speed_command = 0.0f;
                    right_speed_command = 0.0f;
                }
                break;

    }

    float left_duty_command = left_speed_pid.calculate(left_speed_command - odometry_.left_speed, delta_t_);
    float right_duty_command = right_speed_pid.calculate(right_speed_command - odometry_.right_speed, delta_t_);
    motor_pwm_.left_duty = left_duty_command;
    motor_pwm_.right_duty = right_duty_command;
}

float determine_line_pos(uint8_t qtr_state, float last_line_pos, uint8_t num_qtr_on)
{
    static int8_t line_lost_counter = 0;
    float line_pos = 0;

    for (uint8_t i = 0; i < 8; i++)
    {
        if (qtr_state & (1<<i))
        {
            line_pos += (0.009525*i - 0.0333375);
        }
    }
    if (( num_qtr_on ) && (num_qtr_on < 3))
    {
        if (line_lost_counter) line_lost_counter -= 1;
        else line_pos = line_pos/num_qtr_on;
    }
    else
    {
        line_lost_counter = 9;
        line_pos = last_line_pos;
    }
    return (line_pos);
}
